*** /home/njh/src/clamav-devel/trunk/./clamscan/manager.h	2007-03-31 23:10:05.000000000 +0100
--- ./clamscan/manager.h	2007-01-31 08:37:40.000000000 +0000
***************
*** 2,9 ****
   *  Copyright (C) 2002, 2003 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License version 2 as
!  *  published by the Free Software Foundation.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
--- 2,10 ----
   *  Copyright (C) 2002, 2003 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License as published by
!  *  the Free Software Foundation; either version 2 of the License, or
!  *  (at your option) any later version.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
***************
*** 19,37 ****
  #ifndef __MANAGER_H
  #define __MANAGER_H
  
! #if HAVE_CONFIG_H
! #include "clamav-config.h"
! #endif
! 
! #ifdef HAVE_PWD_H
  #include <pwd.h>
  #endif
! 
! #include "libclamav/clamav.h"
! #include "shared/options.h"
  
  int scanmanager(const struct optstruct *opt);
  
! int scanfile(const char *filename, struct cl_engine *engine, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, unsigned int options);
  
  #endif
--- 20,52 ----
  #ifndef __MANAGER_H
  #define __MANAGER_H
  
! #include "libclamav/clamav.h"
! #ifndef	C_WINDOWS
  #include <pwd.h>
  #endif
! #include "options.h"
  
  int scanmanager(const struct optstruct *opt);
  
! int scanfile(const char *filename, struct cl_node *root, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options);
! 
! int scancompressed(const char *filename, struct cl_node *root, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options);
! 
! int scandenied(const char *filename, struct cl_node *root, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options);
! 
! int scandirs(const char *dirname, struct cl_node *root, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options);
! 
! int checkfile(const char *filename, const struct cl_node *root, const struct cl_limits *limits, int options, short printclean);
! 
! int checkstdin(const struct cl_node *root, const struct cl_limits *limits, int options);
! 
! int clamav_unpack(const char *prog, char **args, const char *tmpdir, const struct passwd *user, const struct optstruct *opt);
! 
! void move_infected(const char *filename, const struct optstruct *opt);
! 
! #ifdef	_DEBUG
! /* breaks mspack/qtmd.c :-( */
! #define	free(p)	_free_dbg(p, _NORMAL_BLOCK)
! #endif
  
  #endif
*** /home/njh/src/clamav-devel/trunk/./freshclam/manager.c	2007-03-31 23:10:05.000000000 +0100
--- ./freshclam/manager.c	2007-03-28 22:00:58.000000000 +0100
***************
*** 4,10 ****
   *  Proxy support by Nigel Horne <njh@bandsman.co.uk>
   *  Proxy authorization support by Gernot Tenchio <g.tenchio@telco-tech.de>
   *		     (uses fmt_base64() from libowfat (http://www.fefe.de))
-  *  CDIFF code (C) 2006 Sensory Networks, Inc.
   *
   *  This program is free software; you can redistribute it and/or modify
   *  it under the terms of the GNU General Public License as published by
--- 4,9 ----
***************
*** 210,216 ****
  		break;
  	}
          logg("!Can't get information about %s: %s\n", hostpt, herr);
! 	close(socketfd);
  	return -1;
      }
  
--- 209,215 ----
  		break;
  	}
          logg("!Can't get information about %s: %s\n", hostpt, herr);
! 	closesocket(socketfd);
  	return -1;
      }
  
***************
*** 242,248 ****
  	if(connect(socketfd, (struct sockaddr *) &name, sizeof(struct sockaddr_in)) == -1) {
  #endif
  	    logg("Can't connect to port %d of host %s (IP: %s)\n", port, hostpt, ipaddr);
! 	    close(socketfd);
  	    if((socketfd = getclientsock(localip)) == -1)
  		return -1;
  
--- 241,247 ----
  	if(connect(socketfd, (struct sockaddr *) &name, sizeof(struct sockaddr_in)) == -1) {
  #endif
  	    logg("Can't connect to port %d of host %s (IP: %s)\n", port, hostpt, ipaddr);
! 	    closesocket(socketfd);
  	    if((socketfd = getclientsock(localip)) == -1)
  		return -1;
  
***************
*** 253,259 ****
  	}
      }
  
!     close(socketfd);
      return -2;
  }
  
--- 252,258 ----
  	}
      }
  
!     closesocket(socketfd);
      return -2;
  }
  
*** /home/njh/src/clamav-devel/trunk/./clamd/scanner.c	2007-03-31 23:10:05.000000000 +0100
--- ./clamd/scanner.c	2007-03-06 17:12:12.000000000 +0000
***************
*** 1,11 ****
  /*
   *  Copyright (C) 2002 - 2007 Tomasz Kojm <tkojm@clamav.net>
-  *  MULTISCAN code (C) 2006 Sensory Networks, Inc.
-  *  Written by Tomasz Kojm
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License version 2 as
!  *  published by the Free Software Foundation.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
--- 1,10 ----
  /*
   *  Copyright (C) 2002 - 2007 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License as published by
!  *  the Free Software Foundation; either version 2 of the License, or
!  *  (at your option) any later version.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
***************
*** 475,487 ****
      if(!bound && !portscan) {
  	logg("!ScanStream: Can't find any free port.\n");
  	mdprintf(odesc, "Can't find any free port. ERROR\n");
! 	close(sockfd);
  	return -1;
      } else {
  	listen(sockfd, 1);
  	if(mdprintf(odesc, "PORT %u\n", port) <= 0) {
  	    logg("!ScanStream: error transmitting port.\n");
! 	    close(sockfd);
  	    return -1;
  	}
      }
--- 474,486 ----
      if(!bound && !portscan) {
  	logg("!ScanStream: Can't find any free port.\n");
  	mdprintf(odesc, "Can't find any free port. ERROR\n");
! 	closesocket(sockfd);
  	return -1;
      } else {
  	listen(sockfd, 1);
  	if(mdprintf(odesc, "PORT %u\n", port) <= 0) {
  	    logg("!ScanStream: error transmitting port.\n");
! 	    closesocket(sockfd);
  	    return -1;
  	}
      }
***************
*** 490,506 ****
  	case 0: /* timeout */
  	    mdprintf(odesc, "Accept timeout. ERROR\n");
  	    logg("!ScanStream %u: accept timeout.\n", port);
! 	    close(sockfd);
  	    return -1;
  	case -1:
  	    mdprintf(odesc, "Accept poll. ERROR\n");
  	    logg("!ScanStream %u: accept poll failed.\n", port);
! 	    close(sockfd);
  	    return -1;
      }
  
      if((acceptd = accept(sockfd, NULL, NULL)) == -1) {
! 	close(sockfd);
  	mdprintf(odesc, "accept() ERROR\n");
  	logg("!ScanStream %u: accept() failed.\n", port);
  	return -1;
--- 489,505 ----
  	case 0: /* timeout */
  	    mdprintf(odesc, "Accept timeout. ERROR\n");
  	    logg("!ScanStream %u: accept timeout.\n", port);
! 	    closesocket(sockfd);
  	    return -1;
  	case -1:
  	    mdprintf(odesc, "Accept poll. ERROR\n");
  	    logg("!ScanStream %u: accept poll failed.\n", port);
! 	    closesocket(sockfd);
  	    return -1;
      }
  
      if((acceptd = accept(sockfd, NULL, NULL)) == -1) {
! 	closesocket(sockfd);
  	mdprintf(odesc, "accept() ERROR\n");
  	logg("!ScanStream %u: accept() failed.\n", port);
  	return -1;
***************
*** 510,516 ****
  
      if ((tmpname = cli_gentempdesc(NULL, &tmpd)) == NULL) {
  	shutdown(sockfd, 2);
! 	close(sockfd);
  	close(acceptd);
  	mdprintf(odesc, "tempfile() failed. ERROR\n");
  	logg("!ScanStream %u: Can't create temporary file.\n", port);
--- 509,515 ----
  
      if ((tmpname = cli_gentempdesc(NULL, &tmpd)) == NULL) {
  	shutdown(sockfd, 2);
! 	closesocket(sockfd);
  	close(acceptd);
  	mdprintf(odesc, "tempfile() failed. ERROR\n");
  	logg("!ScanStream %u: Can't create temporary file.\n", port);
*** /home/njh/src/clamav-devel/trunk/./clamd/clamd.c	2007-03-31 23:10:05.000000000 +0100
--- ./clamd/clamd.c	2007-03-21 09:00:00.000000000 +0000
***************
*** 2,9 ****
   *  Copyright (C) 2002 - 2005 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License version 2 as
!  *  published by the Free Software Foundation.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
--- 2,10 ----
   *  Copyright (C) 2002 - 2005 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License as published by
!  *  the Free Software Foundation; either version 2 of the License, or
!  *  (at your option) any later version.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
***************
*** 35,41 ****
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <time.h>
! #ifndef	C_WINDOWS
  #include <pwd.h>
  #include <grp.h>
  #endif
--- 36,44 ----
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <time.h>
! #ifdef	C_WINDOWS
! #include <direct.h>	/* for chdir */
! #else
  #include <pwd.h>
  #include <grp.h>
  #endif
***************
*** 64,69 ****
--- 67,75 ----
  #include "others.h"
  #include "shared.h"
  
+ #ifndef	C_WINDOWS
+ #define	closesocket(s)	close(s)
+ #endif
  
  short debug_mode = 0, logok = 0;
  short foreground = 0;
***************
*** 85,91 ****
--- 91,99 ----
  {
  	struct cfgstruct *copt;
  	const struct cfgstruct *cpt;
+ #ifndef	C_WINDOWS
          struct passwd *user = NULL;
+ #endif
  	time_t currtime;
  	struct cl_engine *engine = NULL;
  	const char *dbdir, *cfgfile;
***************
*** 285,292 ****
--- 293,302 ----
  
      logg("clamd daemon "VERSION" (OS: "TARGET_OS_TYPE", ARCH: "TARGET_ARCH_TYPE", CPU: "TARGET_CPU_TYPE")\n");
  
+ #ifndef	C_WINDOWS
      if(user)
  	logg("Running as user %s (UID %u, GID %u)\n", user->pw_name, user->pw_uid, user->pw_gid);
+ #endif
  
      if(logg_size)
  	logg("Log file size limited to %d bytes.\n", logg_size);
***************
*** 366,372 ****
  	    logg_close();
  	    freecfg(copt);
  	    if(tcpsock)
! 		close(lsockets[0]);
  	    return 1;
  	}
  	nlsockets++;
--- 376,382 ----
  	    logg_close();
  	    freecfg(copt);
  	    if(tcpsock)
! 		closesocket(lsockets[0]);
  	    return 1;
  	}
  	nlsockets++;
*** /home/njh/src/clamav-devel/trunk/./clamd/server-th.c	2007-03-27 09:06:14.000000000 +0100
--- ./clamd/server-th.c	2007-03-27 09:06:34.000000000 +0100
***************
*** 588,594 ****
  		client_conn->socketds = socketds;
  		client_conn->nsockets = nsockets;
  		if (!thrmgr_dispatch(thr_pool, client_conn)) {
! 		    close(client_conn->sd);
  		    free(client_conn);
  		    logg("!thread dispatch failed\n");
  		}
--- 588,594 ----
  		client_conn->socketds = socketds;
  		client_conn->nsockets = nsockets;
  		if (!thrmgr_dispatch(thr_pool, client_conn)) {
! 		    closesocket(client_conn->sd);
  		    free(client_conn);
  		    logg("!thread dispatch failed\n");
  		}
***************
*** 596,604 ****
  
  	pthread_mutex_lock(&exit_mutex);
  	if(progexit) {
  	    if (new_sd >= 0) {
! 		close(new_sd);
  	    }
  	    pthread_mutex_unlock(&exit_mutex);
  	    break;
  	}
--- 596,608 ----
  
  	pthread_mutex_lock(&exit_mutex);
  	if(progexit) {
+ #ifdef	C_WINDOWS
+ 		closesocket(new_sd);
+ #else
  	    if (new_sd >= 0) {
! 		closesocket(new_sd);
  	    }
+ #endif
  	    pthread_mutex_unlock(&exit_mutex);
  	    break;
  	}
***************
*** 627,634 ****
  	    engine = reload_db(engine, dboptions, copt, FALSE, &ret);
  	    if(ret) {
  		logg("Terminating because of a fatal error.\n");
  		if(new_sd >= 0)
! 		    close(new_sd);
  		break;
  	    }
  	    pthread_mutex_lock(&reload_mutex);
--- 631,640 ----
  	    engine = reload_db(engine, dboptions, copt, FALSE, &ret);
  	    if(ret) {
  		logg("Terminating because of a fatal error.\n");
+ #ifndef	C_WINDOWS
  		if(new_sd >= 0)
! #endif
! 		    closesocket(new_sd);
  		break;
  	    }
  	    pthread_mutex_lock(&reload_mutex);
*** /home/njh/src/clamav-devel/trunk/./clamd/clamuko.c	2007-03-31 23:10:05.000000000 +0100
--- ./clamd/clamuko.c	2007-02-11 15:13:50.000000000 +0000
***************
*** 2,9 ****
   *  Copyright (C) 2002 - 2005 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License version 2 as
!  *  published by the Free Software Foundation.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
--- 2,10 ----
   *  Copyright (C) 2002 - 2005 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License as published by
!  *  the Free Software Foundation; either version 2 of the License, or
!  *  (at your option) any later version.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
*** /home/njh/src/clamav-devel/trunk/./clamd/tcpserver.c	2007-03-31 23:10:05.000000000 +0100
--- ./clamd/tcpserver.c	2007-03-06 17:15:34.000000000 +0000
***************
*** 2,9 ****
   *  Copyright (C) 2002 - 2005 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License version 2 as
!  *  published by the Free Software Foundation.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
--- 2,10 ----
   *  Copyright (C) 2002 - 2005 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License as published by
!  *  the Free Software Foundation; either version 2 of the License, or
!  *  (at your option) any later version.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
***************
*** 51,56 ****
--- 52,61 ----
  #include "server.h"
  #include "tcpserver.h"
  
+ #ifndef	C_WINDOWS
+ #define	closesocket(s)	close(s)
+ #endif
+ 
  int tcpserver(const struct cfgstruct *copt)
  {
  	struct sockaddr_in server;
***************
*** 87,93 ****
      if(bind(sockfd, (struct sockaddr *) &server, sizeof(struct sockaddr_in)) == -1) {
  	estr = strerror(errno);
  	logg("!bind() error: %s\n", estr);
! 	close(sockfd);
  	return -1;
      } else {
  	if(taddr->enabled)
--- 92,98 ----
      if(bind(sockfd, (struct sockaddr *) &server, sizeof(struct sockaddr_in)) == -1) {
  	estr = strerror(errno);
  	logg("!bind() error: %s\n", estr);
! 	closesocket(sockfd);
  	return -1;
      } else {
  	if(taddr->enabled)
***************
*** 102,108 ****
      if(listen(sockfd, backlog) == -1) {
  	estr = strerror(errno);
  	logg("!listen() error: %s\n", estr);
! 	close(sockfd);
  	return -1;
      }
  
--- 107,113 ----
      if(listen(sockfd, backlog) == -1) {
  	estr = strerror(errno);
  	logg("!listen() error: %s\n", estr);
! 	closesocket(sockfd);
  	return -1;
      }
  
*** /home/njh/src/clamav-devel/trunk/./clamdscan/clamdscan.c	2007-03-31 23:10:05.000000000 +0100
--- ./clamdscan/clamdscan.c	2007-02-24 09:46:48.000000000 +0000
***************
*** 2,9 ****
   *  Copyright (C) 2002 - 2006 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License version 2 as
!  *  published by the Free Software Foundation.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
--- 2,10 ----
   *  Copyright (C) 2002 - 2006 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License as published by
!  *  the Free Software Foundation; either version 2 of the License, or
!  *  (at your option) any later version.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
***************
*** 15,30 ****
   *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   *  MA 02110-1301, USA.
   */
  
  #if HAVE_CONFIG_H
  #include "clamav-config.h"
  #endif
- 
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <sys/time.h>
  #include <time.h>
  #include <signal.h>
  
--- 16,43 ----
   *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   *  MA 02110-1301, USA.
   */
+  
+ #ifdef	_MSC_VER
+ #include <windows.h>
+ #include <winsock.h>
+ #endif
  
  #if HAVE_CONFIG_H
  #include "clamav-config.h"
  #endif
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
+ #ifdef	HAVE_UNISTD_H
  #include <unistd.h>
+ #endif
+ #ifdef	C_WINDOWS
+ #ifdef	CL_THREAD_SAFE
+ #include <pthread.h>
+ #endif
+ #else
  #include <sys/time.h>
+ #endif
  #include <time.h>
  #include <signal.h>
  
***************
*** 47,60 ****
  {
  	int ds, dms, ret, infected;
  	struct timeval t1, t2;
  	struct timezone tz;
  	time_t starttime;
  	struct optstruct *opt;
  	const char *clamdscan_accepted[] = { "help", "version", "verbose", "quiet",
  				  "stdout", "log", "move", "copy", "remove",
  				  "config-file", "no-summary",
  				  "disable-summary", "multiscan", NULL };
! 
  
      opt = opt_parse(argc, argv, clamscan_shortopt, clamscan_longopt, clamdscan_accepted);
      if(!opt) {
--- 60,81 ----
  {
  	int ds, dms, ret, infected;
  	struct timeval t1, t2;
+ #ifndef	C_WINDOWS
  	struct timezone tz;
+ #endif
  	time_t starttime;
  	struct optstruct *opt;
  	const char *clamdscan_accepted[] = { "help", "version", "verbose", "quiet",
  				  "stdout", "log", "move", "copy", "remove",
  				  "config-file", "no-summary",
  				  "disable-summary", "multiscan", NULL };
! 				  
! #ifdef	C_WINDOWS
! 	if(!pthread_win32_process_attach_np()) {
! 		mprintf("!Can't start the win32 pthreads layer\n");
! 		return 1;
! 	}
! #endif
  
      opt = opt_parse(argc, argv, clamscan_shortopt, clamscan_longopt, clamdscan_accepted);
      if(!opt) {
***************
*** 103,115 ****
      time(&starttime);
      /* ctime() does \n, but I need it once more */
  
!     gettimeofday(&t1, &tz);
  
      ret = client(opt, &infected);
  
      /* TODO: Implement STATUS in clamd */
      if(!opt_check(opt, "disable-summary") && !opt_check(opt, "no-summary")) {
  	gettimeofday(&t2, &tz);
  	ds = t2.tv_sec - t1.tv_sec;
  	dms = t2.tv_usec - t1.tv_usec;
  	ds -= (dms < 0) ? (1):(0);
--- 124,144 ----
      time(&starttime);
      /* ctime() does \n, but I need it once more */
  
! #ifdef	C_WINDOWS
! 	gettimeofday(&t1, NULL);
! #else
! 	gettimeofday(&t1, &tz);
! #endif
  
      ret = client(opt, &infected);
  
      /* TODO: Implement STATUS in clamd */
      if(!opt_check(opt, "disable-summary") && !opt_check(opt, "no-summary")) {
+ #ifdef	C_WINDOWS
+ 	gettimeofday(&t2, NULL);
+ #else
  	gettimeofday(&t2, &tz);
+ #endif
  	ds = t2.tv_sec - t1.tv_sec;
  	dms = t2.tv_usec - t1.tv_usec;
  	ds -= (dms < 0) ? (1):(0);
***************
*** 126,131 ****
--- 155,169 ----
      }
  
      opt_free(opt);
+ 
+ #ifdef	C_WINDOWS
+ 	WSACleanup();
+ 	if(!pthread_win32_process_detach_np()) {
+ 		mprintf("!Can't stop the win32 pthreads layer\n");
+ 		return 1;
+ 	}
+ #endif
+ 
      exit(ret);
  }
  
*** /home/njh/src/clamav-devel/trunk/./clamdscan/client.c	2007-03-31 23:10:05.000000000 +0100
--- ./clamdscan/client.c	2007-02-28 16:46:52.000000000 +0000
***************
*** 2,9 ****
   *  Copyright (C) 2002 - 2007 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License version 2 as
!  *  published by the Free Software Foundation.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
--- 2,10 ----
   *  Copyright (C) 2002 - 2007 Tomasz Kojm <tkojm@clamav.net>
   *
   *  This program is free software; you can redistribute it and/or modify
!  *  it under the terms of the GNU General Public License as published by
!  *  the Free Software Foundation; either version 2 of the License, or
!  *  (at your option) any later version.
   *
   *  This program is distributed in the hope that it will be useful,
   *  but WITHOUT ANY WARRANTY; without even the implied warranty of
***************
*** 15,36 ****
--- 16,44 ----
   *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   *  MA 02110-1301, USA.
   */
+ #ifdef	_MSC_VER
+ #include <winsock.h>
+ #endif
  
  #if HAVE_CONFIG_H
  #include "clamav-config.h"
  #endif
  
  #include <stdio.h>
+ #ifdef	HAVE_UNISTD_H
  #include <unistd.h>
+ #endif
  #include <string.h>
  #include <sys/types.h>
  #include <sys/stat.h>
+ #ifndef	C_WINDOWS
  #include <sys/socket.h>
  #include <sys/un.h>
  #include <netinet/in.h>
  #include <arpa/inet.h>
  #include <netdb.h>
  #include <utime.h>
+ #endif
  #include <errno.h>
  
  #ifdef HAVE_SYS_UIO_H
***************
*** 52,63 ****
--- 60,139 ----
  # define SOCKET_INET	AF_INET
  #endif
  
+ #ifndef	C_WINDOWS
+ #define	closesocket(s)	close(s)
+ #endif
+ 
  /* #define ENABLE_FD_PASSING	    FIXME: Doesn't work yet */
  
  void move_infected(const char *filename, const struct optstruct *opt);
  int notremoved = 0, notmoved = 0;
  static int ncore = 0;
  
+ #ifdef	C_WINDOWS
+ static  int     get_a_line(int sockd, char *buf, size_t len);
+ 
+ static int
+ dsresult(int sockd, const struct optstruct *opt)
+ {
+ 	char buff[BUFSIZ], *pt;
+ 	int infected = 0, waserror = 0;
+ 
+ 	while(get_a_line(sockd, buff, sizeof(buff))) {
+ 		if(strstr(buff, "FOUND\n")) {
+ 			infected++;
+ 			logg("%s", buff);
+ 			if(opt_check(opt, "move") || opt_check(opt, "copy")) {
+ 				/* filename: Virus FOUND */
+ 				if((pt = strrchr(buff, ':'))) {
+ 					*pt = 0;
+ 					move_infected(buff, opt);
+ 				} else
+ 					mprintf("@Broken data format. File not %s.\n", opt_check(opt, "move") ? "moved" : "copied");
+ 			} else if(opt_check(opt, "remove")) {
+ 				if(!(pt = strrchr(buff, ':')))
+ 					mprintf("@Broken data format. File not removed.\n");
+ 				else {
+ 					*pt = 0;
+ 					if(unlink(buff)) {
+ 						mprintf("%s: Can't remove.\n", buff);
+ 						logg("%s: Can't remove.\n", buff);
+ 						notremoved++;
+ 					} else {
+ 						mprintf("%s: Removed.\n", buff);
+ 						logg("%s: Removed.\n", buff);
+ 					}
+ 				}
+ 			}
+ 		}
+ 
+ 		if(strstr(buff, "ERROR\n")) {
+ 			logg("%s", buff);
+ 			waserror = 1;
+ 		}
+ 	}
+ 
+ 	return infected ? infected : (waserror ? -1 : 0);
+ }
+ 
+ static int
+ get_a_line(int sockd, char *buf, size_t len)
+ {
+ 	char *ptr;
+ 
+ 	for(ptr = buf; ptr < &buf[len]; ptr++) {
+ 		/* FIXME: very inefficient to call recv so many times */
+ 		if(recv(sockd, ptr, sizeof(char), 0) <= 0)
+ 			return 0;
+ 		if(*ptr == '\n') {
+ 			*++ptr = '\0';
+ 			return 1;
+ 		}
+ 	}
+ 	return 1;
+ }
+ 
+ #else
  static int dsresult(int sockd, const struct optstruct *opt)
  {
  	int infected = 0, waserror = 0;
***************
*** 68,74 ****
  #ifndef C_OS2
      if((fd = fdopen(dup(sockd), "r")) == NULL) {
  #else /* FIXME: accoriding to YD OS/2 does not support dup() for sockets */
!     if((fd = fdopen(sockd, "r")) == NULL) {
  #endif
  	logg("^Can't open descriptor for reading.\n");
  	return -1;
--- 144,150 ----
  #ifndef C_OS2
      if((fd = fdopen(dup(sockd), "r")) == NULL) {
  #else /* FIXME: accoriding to YD OS/2 does not support dup() for sockets */
!     if((fd = fdopen(sockd, "rb")) == NULL) {
  #endif
  	logg("^Can't open descriptor for reading.\n");
  	return -1;
***************
*** 116,121 ****
--- 192,198 ----
  
      return infected ? infected : (waserror ? -1 : 0);
  }
+ #endif	/* C_WINDOWS */
  
  static int dsfile(int sockd, const char *scantype, const char *filename, const struct optstruct *opt)
  {
***************
*** 126,132 ****
      scancmd = malloc(strlen(filename) + 20);
      sprintf(scancmd, "%s %s", scantype, filename);
  
!     if(write(sockd, scancmd, strlen(scancmd)) <= 0) {
  	logg("^Can't write to the socket.\n");
  	free(scancmd);
  	return -1;
--- 203,209 ----
      scancmd = malloc(strlen(filename) + 20);
      sprintf(scancmd, "%s %s", scantype, filename);
  
!     if(send(sockd, scancmd, strlen(scancmd), 0) <= 0) {
  	logg("^Can't write to the socket.\n");
  	free(scancmd);
  	return -1;
***************
*** 200,206 ****
  	char buff[4096], *pt;
  
  
!     if(write(sockd, "STREAM", 6) <= 0) {
  	logg("^Can't write to the socket.\n");
  	return 2;
      }
--- 277,283 ----
  	char buff[4096], *pt;
  
  
!     if(send(sockd, "STREAM", 6, 0) <= 0) {
  	logg("^Can't write to the socket.\n");
  	return 2;
      }
***************
*** 252,258 ****
      }
  
      if(connect(wsockd, (struct sockaddr *) &server, sizeof(struct sockaddr_in)) < 0) {
! 	close(wsockd);
  	perror("connect()");
  	logg("^Can't connect to clamd [port: %d].\n", port);
  	return -1;
--- 329,335 ----
      }
  
      if(connect(wsockd, (struct sockaddr *) &server, sizeof(struct sockaddr_in)) < 0) {
! 	closesocket(wsockd);
  	perror("connect()");
  	logg("^Can't connect to clamd [port: %d].\n", port);
  	return -1;
***************
*** 261,271 ****
      while((bread = read(0, buff, sizeof(buff))) > 0) {
  	if(write(wsockd, buff, bread) <= 0) {
  	    logg("^Can't write to the socket.\n");
! 	    close(wsockd);
  	    return -1;
  	}
      }
!     close(wsockd);
  
      memset(buff, 0, sizeof(buff));
      while((bread = read(sockd, buff, sizeof(buff))) > 0) {
--- 338,348 ----
      while((bread = read(0, buff, sizeof(buff))) > 0) {
  	if(write(wsockd, buff, bread) <= 0) {
  	    logg("^Can't write to the socket.\n");
! 	    closesocket(wsockd);
  	    return -1;
  	}
      }
!     closesocket(wsockd);
  
      memset(buff, 0, sizeof(buff));
      while((bread = read(sockd, buff, sizeof(buff))) > 0) {
***************
*** 310,316 ****
--- 387,395 ----
  
  static int dconnect(const struct optstruct *opt)
  {
+ #ifndef	C_WINDOWS
  	struct sockaddr_un server;
+ #endif
  	struct sockaddr_in server2;
  	struct hostent *he;
  	struct cfgstruct *copt, *cpt;
***************
*** 326,338 ****
--- 405,423 ----
  	return -1;
      }
  
+ #ifndef	C_WINDOWS
      memset((char *) &server, 0, sizeof(server));
+ #endif
      memset((char *) &server2, 0, sizeof(server2));
  
      /* Set default address to connect to */
      server2.sin_addr.s_addr = inet_addr("127.0.0.1");    
  
      if((cpt = cfgopt(copt, "LocalSocket"))->enabled) {
+ #ifdef	C_WINDOWS
+ 	logg("^LocalSocket is not supported under Windows");
+ #else
+     if((cpt = cfgopt(copt, "LocalSocket"))->enabled) {
  
  	server.sun_family = AF_UNIX;
  	strncpy(server.sun_path, cpt->strarg, sizeof(server.sun_path));
***************
*** 345,359 ****
  	}
  
  	if(connect(sockd, (struct sockaddr *) &server, sizeof(struct sockaddr_un)) < 0) {
! 	    close(sockd);
  	    perror("connect()");
  	    logg("^Can't connect to clamd.\n");
  	    freecfg(copt);
  	    return -1;
  	}
! 
!     } else if((cpt = cfgopt(copt, "TCPSocket"))->enabled) {
! 
  	if((sockd = socket(SOCKET_INET, SOCK_STREAM, 0)) < 0) {
  	    perror("socket()");
  	    logg("^Can't create the socket.\n");
--- 430,453 ----
  	}
  
  	if(connect(sockd, (struct sockaddr *) &server, sizeof(struct sockaddr_un)) < 0) {
! 	    closesocket(sockd);
  	    perror("connect()");
  	    logg("^Can't connect to clamd.\n");
  	    freecfg(copt);
  	    return -1;
  	}
! #endif
!   
!       } else if((cpt = cfgopt(copt, "TCPSocket"))->enabled) {
! #ifdef  C_WINDOWS
!                 WSADATA wsaData;
! 
!                 if(WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) {
!                         logg("!Error at WSAStartup(): %d\n", WSAGetLastError());
!                         return -1;
!                 }
! #endif
!   
  	if((sockd = socket(SOCKET_INET, SOCK_STREAM, 0)) < 0) {
  	    perror("socket()");
  	    logg("^Can't create the socket.\n");
***************
*** 366,372 ****
  
  	if((cpt = cfgopt(copt, "TCPAddr"))->enabled) {
  	    if ((he = gethostbyname(cpt->strarg)) == 0) {
! 		close(sockd);
  		perror("gethostbyname()");
  		logg("^Can't lookup clamd hostname.\n");
  		freecfg(copt);
--- 460,466 ----
  
  	if((cpt = cfgopt(copt, "TCPAddr"))->enabled) {
  	    if ((he = gethostbyname(cpt->strarg)) == 0) {
! 		closesocket(sockd);
  		perror("gethostbyname()");
  		logg("^Can't lookup clamd hostname.\n");
  		freecfg(copt);
***************
*** 376,382 ****
  	}
  
  	if(connect(sockd, (struct sockaddr *) &server2, sizeof(struct sockaddr_in)) < 0) {
! 	    close(sockd);
  	    perror("connect()");
  	    logg("^Can't connect to clamd.\n");
  	    freecfg(copt);
--- 470,476 ----
  	}
  
  	if(connect(sockd, (struct sockaddr *) &server2, sizeof(struct sockaddr_in)) < 0) {
! 	    closesocket(sockd);
  	    perror("connect()");
  	    logg("^Can't connect to clamd.\n");
  	    freecfg(copt);
***************
*** 428,434 ****
  	else
  	    errors++;
  
! 	close(sockd);
  
  #if defined(ENABLE_FD_PASSING) && defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR)) && !defined(C_CYGWIN)
      } else if(!strcmp(opt->filename, "-")) { /* scan data from stdin */
--- 522,528 ----
  	else
  	    errors++;
  
! 	closesocket(sockd);
  
  #if defined(ENABLE_FD_PASSING) && defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR)) && !defined(C_CYGWIN)
      } else if(!strcmp(opt->filename, "-")) { /* scan data from stdin */
***************
*** 440,446 ****
  	else
  	    errors++;
  
! 	close(sockd);
  #else
      } else if(!strcmp(opt->filename, "-")) { /* scan data from stdin */
  	if((sockd = dconnect(opt)) < 0)
--- 534,540 ----
  	else
  	    errors++;
  
! 	closesocket(sockd);
  #else
      } else if(!strcmp(opt->filename, "-")) { /* scan data from stdin */
  	if((sockd = dconnect(opt)) < 0)
***************
*** 451,457 ****
  	else
  	    errors++;
  
! 	close(sockd);
  #endif
  
      } else {
--- 545,551 ----
  	else
  	    errors++;
  
! 	closesocket(sockd);
  #endif
  
      } else {
***************
*** 486,492 ****
  			else
  			    errors++;
  
! 			close(sockd);
  			break;
  
  		    default:
--- 580,586 ----
  			else
  			    errors++;
  
! 			closesocket(sockd);
  			break;
  
  		    default:
***************
*** 508,515 ****
  	struct stat fstat, mfstat;
  	int n, len, movefilename_size;
  	int moveflag = opt_check(opt, "move");
  	struct utimbuf ubuf;
! 
  
      if((moveflag && !(movedir = opt_arg(opt, "move"))) ||
          (!moveflag && !(movedir = opt_arg(opt, "copy")))) {
--- 602,610 ----
  	struct stat fstat, mfstat;
  	int n, len, movefilename_size;
  	int moveflag = opt_check(opt, "move");
+ #ifndef	C_WINDOWS
  	struct utimbuf ubuf;
! #endif
  
      if((moveflag && !(movedir = opt_arg(opt, "move"))) ||
          (!moveflag && !(movedir = opt_arg(opt, "copy")))) {
***************
*** 594,602 ****
  	chmod(movefilename, fstat.st_mode);
  	chown(movefilename, fstat.st_uid, fstat.st_gid);
  
! 	ubuf.actime = fstat.st_atime;
! 	ubuf.modtime = fstat.st_mtime;
! 	utime(movefilename, &ubuf);
  
  	if(moveflag && unlink(filename)) {
  	    logg("^cannot unlink '%s': %s\n", filename, strerror(errno));
--- 689,699 ----
  	chmod(movefilename, fstat.st_mode);
  	chown(movefilename, fstat.st_uid, fstat.st_gid);
  
! #ifndef	C_WINDOWS
!   	ubuf.actime = fstat.st_atime;
!   	ubuf.modtime = fstat.st_mtime;
!   	utime(movefilename, &ubuf);
! #endif
  
  	if(moveflag && unlink(filename)) {
  	    logg("^cannot unlink '%s': %s\n", filename, strerror(errno));
