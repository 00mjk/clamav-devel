*** /home/njh/src/clamav-devel/trunk/./clamscan/manager.h	2007-02-28 15:05:17.000000000 +0000
--- ./clamscan/manager.h	2007-01-31 09:37:40.000000000 +0000
***************
*** 20,38 ****
  #ifndef __MANAGER_H
  #define __MANAGER_H
  
! #if HAVE_CONFIG_H
! #include "clamav-config.h"
! #endif
! 
! #ifdef HAVE_PWD_H
  #include <pwd.h>
  #endif
! 
! #include "libclamav/clamav.h"
! #include "shared/options.h"
  
  int scanmanager(const struct optstruct *opt);
  
! int scanfile(const char *filename, struct cl_engine *engine, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, unsigned int options);
  
  #endif
--- 20,52 ----
  #ifndef __MANAGER_H
  #define __MANAGER_H
  
! #include "libclamav/clamav.h"
! #ifndef	C_WINDOWS
  #include <pwd.h>
  #endif
! #include "options.h"
  
  int scanmanager(const struct optstruct *opt);
  
! int scanfile(const char *filename, struct cl_node *root, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options);
! 
! int scancompressed(const char *filename, struct cl_node *root, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options);
! 
! int scandenied(const char *filename, struct cl_node *root, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options);
! 
! int scandirs(const char *dirname, struct cl_node *root, const struct passwd *user, const struct optstruct *opt, const struct cl_limits *limits, int options);
! 
! int checkfile(const char *filename, const struct cl_node *root, const struct cl_limits *limits, int options, short printclean);
! 
! int checkstdin(const struct cl_node *root, const struct cl_limits *limits, int options);
! 
! int clamav_unpack(const char *prog, char **args, const char *tmpdir, const struct passwd *user, const struct optstruct *opt);
! 
! void move_infected(const char *filename, const struct optstruct *opt);
! 
! #ifdef	_DEBUG
! /* breaks mspack/qtmd.c :-( */
! #define	free(p)	_free_dbg(p, _NORMAL_BLOCK)
! #endif
  
  #endif
*** /home/njh/src/clamav-devel/trunk/./shared/misc.c	2007-03-05 19:16:44.000000000 +0000
--- ./shared/misc.c	2007-03-05 19:17:22.000000000 +0000
***************
*** 233,239 ****
  int isnumb(const char *str)
  {
      while(*str) {
! 	if(!isdigit(*str))
  	    return 0;
  	str++;
      }
--- 233,239 ----
  int isnumb(const char *str)
  {
      while(*str) {
! 	if(!isdigit(*str & 0xFF))
  	    return 0;
  	str++;
      }
*** /home/njh/src/clamav-devel/trunk/./freshclam/manager.c	2007-02-28 15:06:52.000000000 +0000
--- ./freshclam/manager.c	2007-03-05 22:58:52.000000000 +0000
***************
*** 193,199 ****
  		break;
  	}
          logg("!Can't get information about %s: %s\n", hostpt, herr);
! 	close(socketfd);
  	return -1;
      }
  
--- 193,199 ----
  		break;
  	}
          logg("!Can't get information about %s: %s\n", hostpt, herr);
! 	closesocket(socketfd);
  	return -1;
      }
  
*** /home/njh/src/clamav-devel/trunk/./freshclam/freshclam.c	2007-02-19 19:26:21.000000000 +0000
--- ./freshclam/freshclam.c	2007-02-24 21:45:28.000000000 +0000
***************
*** 247,252 ****
--- 247,258 ----
  	    {0, 0, 0, 0}
      	};
  
+ #ifdef	C_WINDOWS
+ 	if(!pthread_win32_process_attach_np()) {
+ 		mprintf("!Can't start the win32 pthreads layer\n");
+ 		return 1;
+ 	}
+ #endif
  
      opt = opt_parse(argc, argv, short_options, long_options, NULL);
      if(!opt) {
***************
*** 281,293 ****
  	return 56;
      }
  
- #ifdef C_WINDOWS
-     if(!pthread_win32_process_attach_np()) {
- 	mprintf("!Can't start the win32 pthreads layer\n");
- 	return 63;
-     }
- #endif
- 
      if(opt_check(opt, "http-proxy") || opt_check(opt, "proxy-user"))
  	logg("WARNING: Proxy settings are now only configurable in the config file.\n");
  
--- 287,292 ----
***************
*** 570,581 ****
      opt_free(opt);
  
  #ifdef C_WINDOWS
!     WSACleanup();
! 
!     if(!pthread_win32_process_detach_np()) {
! 	mprintf("!Can't stop the win32 pthreads layer\n");
! 	return 63;
!     }
  #endif
  
      return(ret);
--- 569,580 ----
      opt_free(opt);
  
  #ifdef C_WINDOWS
! 	WSACleanup();
!     
! 	if(!pthread_win32_process_detach_np()) {
! 		mprintf("!Can't stop the win32 pthreads layer\n");
! 		return 1;
! 	}
  #endif
  
      return(ret);
*** /home/njh/src/clamav-devel/trunk/./clamd/scanner.c	2007-02-28 15:06:52.000000000 +0000
--- ./clamd/scanner.c	2007-03-05 22:31:44.000000000 +0000
***************
*** 473,485 ****
      if(!bound && !portscan) {
  	logg("!ScanStream: Can't find any free port.\n");
  	mdprintf(odesc, "Can't find any free port. ERROR\n");
! 	close(sockfd);
  	return -1;
      } else {
  	listen(sockfd, 1);
  	if(mdprintf(odesc, "PORT %d\n", port) <= 0) {
  	    logg("!ScanStream: error transmitting port.\n");
! 	    close(sockfd);
  	    return -1;
  	}
      }
--- 473,485 ----
      if(!bound && !portscan) {
  	logg("!ScanStream: Can't find any free port.\n");
  	mdprintf(odesc, "Can't find any free port. ERROR\n");
! 	closesocket(sockfd);
  	return -1;
      } else {
  	listen(sockfd, 1);
  	if(mdprintf(odesc, "PORT %d\n", port) <= 0) {
  	    logg("!ScanStream: error transmitting port.\n");
! 	    closesocket(sockfd);
  	    return -1;
  	}
      }
***************
*** 488,504 ****
  	case 0: /* timeout */
  	    mdprintf(odesc, "Accept timeout. ERROR\n");
  	    logg("!ScanStream %d: accept timeout.\n", port);
! 	    close(sockfd);
  	    return -1;
  	case -1:
  	    mdprintf(odesc, "Accept poll. ERROR\n");
  	    logg("!ScanStream %d: accept poll failed.\n", port);
! 	    close(sockfd);
  	    return -1;
      }
  
      if((acceptd = accept(sockfd, NULL, NULL)) == -1) {
! 	close(sockfd);
  	mdprintf(odesc, "accept() ERROR\n");
  	logg("!ScanStream %d: accept() failed.\n", port);
  	return -1;
--- 488,504 ----
  	case 0: /* timeout */
  	    mdprintf(odesc, "Accept timeout. ERROR\n");
  	    logg("!ScanStream %d: accept timeout.\n", port);
! 	    closesocket(sockfd);
  	    return -1;
  	case -1:
  	    mdprintf(odesc, "Accept poll. ERROR\n");
  	    logg("!ScanStream %d: accept poll failed.\n", port);
! 	    closesocket(sockfd);
  	    return -1;
      }
  
      if((acceptd = accept(sockfd, NULL, NULL)) == -1) {
! 	closesocket(sockfd);
  	mdprintf(odesc, "accept() ERROR\n");
  	logg("!ScanStream %d: accept() failed.\n", port);
  	return -1;
***************
*** 508,514 ****
  
      if ((tmpname = cli_gentempdesc(NULL, &tmpd)) == NULL) {
  	shutdown(sockfd, 2);
! 	close(sockfd);
  	close(acceptd);
  	mdprintf(odesc, "tempfile() failed. ERROR\n");
  	logg("!ScanStream %d: Can't create temporary file.\n", port);
--- 508,514 ----
  
      if ((tmpname = cli_gentempdesc(NULL, &tmpd)) == NULL) {
  	shutdown(sockfd, 2);
! 	closesocket(sockfd);
  	close(acceptd);
  	mdprintf(odesc, "tempfile() failed. ERROR\n");
  	logg("!ScanStream %d: Can't create temporary file.\n", port);
*** /home/njh/src/clamav-devel/trunk/./clamd/clamd.c	2007-02-28 15:06:52.000000000 +0000
--- ./clamd/clamd.c	2007-03-06 10:13:28.000000000 +0000
***************
*** 65,70 ****
--- 65,73 ----
  #include "others.h"
  #include "shared.h"
  
+ #ifndef	C_WINDOWS
+ #define	closesocket(s)	close(s)
+ #endif
  
  short debug_mode = 0, logok = 0;
  short foreground = 0;
***************
*** 376,382 ****
  	    logg_close();
  	    freecfg(copt);
  	    if(tcpsock)
! 		close(lsockets[0]);
  	    return 1;
  	}
  	nlsockets++;
--- 379,385 ----
  	    logg_close();
  	    freecfg(copt);
  	    if(tcpsock)
! 		closesocket(lsockets[0]);
  	    return 1;
  	}
  	nlsockets++;
*** /home/njh/src/clamav-devel/trunk/./clamd/server-th.c	2007-03-01 22:06:06.000000000 +0000
--- ./clamd/server-th.c	2007-03-05 22:34:44.000000000 +0000
***************
*** 588,594 ****
  		client_conn->socketds = socketds;
  		client_conn->nsockets = nsockets;
  		if (!thrmgr_dispatch(thr_pool, client_conn)) {
! 		    close(client_conn->sd);
  		    free(client_conn);
  		    logg("!thread dispatch failed\n");
  		}
--- 588,594 ----
  		client_conn->socketds = socketds;
  		client_conn->nsockets = nsockets;
  		if (!thrmgr_dispatch(thr_pool, client_conn)) {
! 		    closesocket(client_conn->sd);
  		    free(client_conn);
  		    logg("!thread dispatch failed\n");
  		}
***************
*** 597,603 ****
  	pthread_mutex_lock(&exit_mutex);
  	if(progexit) {
  	    if (new_sd >= 0) {
! 		close(new_sd);
  	    }
  	    pthread_mutex_unlock(&exit_mutex);
  	    break;
--- 597,603 ----
  	pthread_mutex_lock(&exit_mutex);
  	if(progexit) {
  	    if (new_sd >= 0) {
! 		closesocket(new_sd);
  	    }
  	    pthread_mutex_unlock(&exit_mutex);
  	    break;
*** /home/njh/src/clamav-devel/trunk/./clamd/tcpserver.c	2007-02-19 19:26:21.000000000 +0000
--- ./clamd/tcpserver.c	2007-03-05 22:34:16.000000000 +0000
***************
*** 52,57 ****
--- 52,61 ----
  #include "server.h"
  #include "tcpserver.h"
  
+ #ifndef	C_WINDOWS
+ #define	closesocket(s)	close(s)
+ #endif
+ 
  int tcpserver(const struct cfgstruct *copt)
  {
  	struct sockaddr_in server;
***************
*** 88,94 ****
      if(bind(sockfd, (struct sockaddr *) &server, sizeof(struct sockaddr_in)) == -1) {
  	estr = strerror(errno);
  	logg("!bind() error: %s\n", estr);
! 	close(sockfd);
  	return -1;
      } else {
  	if(taddr->enabled)
--- 92,98 ----
      if(bind(sockfd, (struct sockaddr *) &server, sizeof(struct sockaddr_in)) == -1) {
  	estr = strerror(errno);
  	logg("!bind() error: %s\n", estr);
! 	closesocket(sockfd);
  	return -1;
      } else {
  	if(taddr->enabled)
***************
*** 103,109 ****
      if(listen(sockfd, backlog) == -1) {
  	estr = strerror(errno);
  	logg("!listen() error: %s\n", estr);
! 	close(sockfd);
  	return -1;
      }
  
--- 107,113 ----
      if(listen(sockfd, backlog) == -1) {
  	estr = strerror(errno);
  	logg("!listen() error: %s\n", estr);
! 	closesocket(sockfd);
  	return -1;
      }
  
*** /home/njh/src/clamav-devel/trunk/./clamdscan/clamdscan.c	2007-02-19 19:26:14.000000000 +0000
--- ./clamdscan/clamdscan.c	2007-02-24 10:46:48.000000000 +0000
***************
*** 16,31 ****
   *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   *  MA 02110-1301, USA.
   */
  
  #if HAVE_CONFIG_H
  #include "clamav-config.h"
  #endif
- 
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <sys/time.h>
  #include <time.h>
  #include <signal.h>
  
--- 16,43 ----
   *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   *  MA 02110-1301, USA.
   */
+  
+ #ifdef	_MSC_VER
+ #include <windows.h>
+ #include <winsock.h>
+ #endif
  
  #if HAVE_CONFIG_H
  #include "clamav-config.h"
  #endif
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
+ #ifdef	HAVE_UNISTD_H
  #include <unistd.h>
+ #endif
+ #ifdef	C_WINDOWS
+ #ifdef	CL_THREAD_SAFE
+ #include <pthread.h>
+ #endif
+ #else
  #include <sys/time.h>
+ #endif
  #include <time.h>
  #include <signal.h>
  
***************
*** 48,61 ****
  {
  	int ds, dms, ret, infected;
  	struct timeval t1, t2;
  	struct timezone tz;
  	time_t starttime;
  	struct optstruct *opt;
  	const char *clamdscan_accepted[] = { "help", "version", "verbose", "quiet",
  				  "stdout", "log", "move", "copy", "remove",
  				  "config-file", "no-summary",
  				  "disable-summary", "multiscan", NULL };
! 
  
      opt = opt_parse(argc, argv, clamscan_shortopt, clamscan_longopt, clamdscan_accepted);
      if(!opt) {
--- 60,81 ----
  {
  	int ds, dms, ret, infected;
  	struct timeval t1, t2;
+ #ifndef	C_WINDOWS
  	struct timezone tz;
+ #endif
  	time_t starttime;
  	struct optstruct *opt;
  	const char *clamdscan_accepted[] = { "help", "version", "verbose", "quiet",
  				  "stdout", "log", "move", "copy", "remove",
  				  "config-file", "no-summary",
  				  "disable-summary", "multiscan", NULL };
! 				  
! #ifdef	C_WINDOWS
! 	if(!pthread_win32_process_attach_np()) {
! 		mprintf("!Can't start the win32 pthreads layer\n");
! 		return 1;
! 	}
! #endif
  
      opt = opt_parse(argc, argv, clamscan_shortopt, clamscan_longopt, clamdscan_accepted);
      if(!opt) {
***************
*** 104,116 ****
      time(&starttime);
      /* ctime() does \n, but I need it once more */
  
!     gettimeofday(&t1, &tz);
  
      ret = client(opt, &infected);
  
      /* TODO: Implement STATUS in clamd */
      if(!opt_check(opt, "disable-summary") && !opt_check(opt, "no-summary")) {
  	gettimeofday(&t2, &tz);
  	ds = t2.tv_sec - t1.tv_sec;
  	dms = t2.tv_usec - t1.tv_usec;
  	ds -= (dms < 0) ? (1):(0);
--- 124,144 ----
      time(&starttime);
      /* ctime() does \n, but I need it once more */
  
! #ifdef	C_WINDOWS
! 	gettimeofday(&t1, NULL);
! #else
! 	gettimeofday(&t1, &tz);
! #endif
  
      ret = client(opt, &infected);
  
      /* TODO: Implement STATUS in clamd */
      if(!opt_check(opt, "disable-summary") && !opt_check(opt, "no-summary")) {
+ #ifdef	C_WINDOWS
+ 	gettimeofday(&t2, NULL);
+ #else
  	gettimeofday(&t2, &tz);
+ #endif
  	ds = t2.tv_sec - t1.tv_sec;
  	dms = t2.tv_usec - t1.tv_usec;
  	ds -= (dms < 0) ? (1):(0);
***************
*** 127,132 ****
--- 155,169 ----
      }
  
      opt_free(opt);
+ 
+ #ifdef	C_WINDOWS
+ 	WSACleanup();
+ 	if(!pthread_win32_process_detach_np()) {
+ 		mprintf("!Can't stop the win32 pthreads layer\n");
+ 		return 1;
+ 	}
+ #endif
+ 
      exit(ret);
  }
  
*** /home/njh/src/clamav-devel/trunk/./clamdscan/client.c	2007-02-28 15:06:52.000000000 +0000
--- ./clamdscan/client.c	2007-02-28 17:46:52.000000000 +0000
***************
*** 16,37 ****
--- 16,44 ----
   *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   *  MA 02110-1301, USA.
   */
+ #ifdef	_MSC_VER
+ #include <winsock.h>
+ #endif
  
  #if HAVE_CONFIG_H
  #include "clamav-config.h"
  #endif
  
  #include <stdio.h>
+ #ifdef	HAVE_UNISTD_H
  #include <unistd.h>
+ #endif
  #include <string.h>
  #include <sys/types.h>
  #include <sys/stat.h>
+ #ifndef	C_WINDOWS
  #include <sys/socket.h>
  #include <sys/un.h>
  #include <netinet/in.h>
  #include <arpa/inet.h>
  #include <netdb.h>
  #include <utime.h>
+ #endif
  #include <errno.h>
  
  #ifdef HAVE_SYS_UIO_H
***************
*** 53,64 ****
--- 60,139 ----
  # define SOCKET_INET	AF_INET
  #endif
  
+ #ifndef	C_WINDOWS
+ #define	closesocket(s)	close(s)
+ #endif
+ 
  /* #define ENABLE_FD_PASSING	    FIXME: Doesn't work yet */
  
  void move_infected(const char *filename, const struct optstruct *opt);
  int notremoved = 0, notmoved = 0;
  static int ncore = 0;
  
+ #ifdef	C_WINDOWS
+ static  int     get_a_line(int sockd, char *buf, size_t len);
+ 
+ static int
+ dsresult(int sockd, const struct optstruct *opt)
+ {
+ 	char buff[BUFSIZ], *pt;
+ 	int infected = 0, waserror = 0;
+ 
+ 	while(get_a_line(sockd, buff, sizeof(buff))) {
+ 		if(strstr(buff, "FOUND\n")) {
+ 			infected++;
+ 			logg("%s", buff);
+ 			if(opt_check(opt, "move") || opt_check(opt, "copy")) {
+ 				/* filename: Virus FOUND */
+ 				if((pt = strrchr(buff, ':'))) {
+ 					*pt = 0;
+ 					move_infected(buff, opt);
+ 				} else
+ 					mprintf("@Broken data format. File not %s.\n", opt_check(opt, "move") ? "moved" : "copied");
+ 			} else if(opt_check(opt, "remove")) {
+ 				if(!(pt = strrchr(buff, ':')))
+ 					mprintf("@Broken data format. File not removed.\n");
+ 				else {
+ 					*pt = 0;
+ 					if(unlink(buff)) {
+ 						mprintf("%s: Can't remove.\n", buff);
+ 						logg("%s: Can't remove.\n", buff);
+ 						notremoved++;
+ 					} else {
+ 						mprintf("%s: Removed.\n", buff);
+ 						logg("%s: Removed.\n", buff);
+ 					}
+ 				}
+ 			}
+ 		}
+ 
+ 		if(strstr(buff, "ERROR\n")) {
+ 			logg("%s", buff);
+ 			waserror = 1;
+ 		}
+ 	}
+ 
+ 	return infected ? infected : (waserror ? -1 : 0);
+ }
+ 
+ static int
+ get_a_line(int sockd, char *buf, size_t len)
+ {
+ 	char *ptr;
+ 
+ 	for(ptr = buf; ptr < &buf[len]; ptr++) {
+ 		/* FIXME: very inefficient to call recv so many times */
+ 		if(recv(sockd, ptr, sizeof(char), 0) <= 0)
+ 			return 0;
+ 		if(*ptr == '\n') {
+ 			*++ptr = '\0';
+ 			return 1;
+ 		}
+ 	}
+ 	return 1;
+ }
+ 
+ #else
  static int dsresult(int sockd, const struct optstruct *opt)
  {
  	int infected = 0, waserror = 0;
***************
*** 69,75 ****
  #ifndef C_OS2
      if((fd = fdopen(dup(sockd), "r")) == NULL) {
  #else /* FIXME: accoriding to YD OS/2 does not support dup() for sockets */
!     if((fd = fdopen(sockd, "r")) == NULL) {
  #endif
  	logg("^Can't open descriptor for reading.\n");
  	return -1;
--- 144,150 ----
  #ifndef C_OS2
      if((fd = fdopen(dup(sockd), "r")) == NULL) {
  #else /* FIXME: accoriding to YD OS/2 does not support dup() for sockets */
!     if((fd = fdopen(sockd, "rb")) == NULL) {
  #endif
  	logg("^Can't open descriptor for reading.\n");
  	return -1;
***************
*** 117,122 ****
--- 192,198 ----
  
      return infected ? infected : (waserror ? -1 : 0);
  }
+ #endif	/* C_WINDOWS */
  
  static int dsfile(int sockd, const char *scantype, const char *filename, const struct optstruct *opt)
  {
***************
*** 127,133 ****
      scancmd = malloc(strlen(filename) + 20);
      sprintf(scancmd, "%s %s", scantype, filename);
  
!     if(write(sockd, scancmd, strlen(scancmd)) <= 0) {
  	logg("^Can't write to the socket.\n");
  	free(scancmd);
  	return -1;
--- 203,209 ----
      scancmd = malloc(strlen(filename) + 20);
      sprintf(scancmd, "%s %s", scantype, filename);
  
!     if(send(sockd, scancmd, strlen(scancmd), 0) <= 0) {
  	logg("^Can't write to the socket.\n");
  	free(scancmd);
  	return -1;
***************
*** 201,207 ****
  	char buff[4096], *pt;
  
  
!     if(write(sockd, "STREAM", 6) <= 0) {
  	logg("^Can't write to the socket.\n");
  	return 2;
      }
--- 277,283 ----
  	char buff[4096], *pt;
  
  
!     if(send(sockd, "STREAM", 6, 0) <= 0) {
  	logg("^Can't write to the socket.\n");
  	return 2;
      }
***************
*** 253,259 ****
      }
  
      if(connect(wsockd, (struct sockaddr *) &server, sizeof(struct sockaddr_in)) < 0) {
! 	close(wsockd);
  	perror("connect()");
  	logg("^Can't connect to clamd [port: %d].\n", port);
  	return -1;
--- 329,335 ----
      }
  
      if(connect(wsockd, (struct sockaddr *) &server, sizeof(struct sockaddr_in)) < 0) {
! 	closesocket(wsockd);
  	perror("connect()");
  	logg("^Can't connect to clamd [port: %d].\n", port);
  	return -1;
***************
*** 262,272 ****
      while((bread = read(0, buff, sizeof(buff))) > 0) {
  	if(write(wsockd, buff, bread) <= 0) {
  	    logg("^Can't write to the socket.\n");
! 	    close(wsockd);
  	    return -1;
  	}
      }
!     close(wsockd);
  
      memset(buff, 0, sizeof(buff));
      while((bread = read(sockd, buff, sizeof(buff))) > 0) {
--- 338,348 ----
      while((bread = read(0, buff, sizeof(buff))) > 0) {
  	if(write(wsockd, buff, bread) <= 0) {
  	    logg("^Can't write to the socket.\n");
! 	    closesocket(wsockd);
  	    return -1;
  	}
      }
!     closesocket(wsockd);
  
      memset(buff, 0, sizeof(buff));
      while((bread = read(sockd, buff, sizeof(buff))) > 0) {
***************
*** 311,317 ****
--- 387,395 ----
  
  static int dconnect(const struct optstruct *opt)
  {
+ #ifndef	C_WINDOWS
  	struct sockaddr_un server;
+ #endif
  	struct sockaddr_in server2;
  	struct hostent *he;
  	struct cfgstruct *copt, *cpt;
***************
*** 327,339 ****
--- 405,423 ----
  	return -1;
      }
  
+ #ifndef	C_WINDOWS
      memset((char *) &server, 0, sizeof(server));
+ #endif
      memset((char *) &server2, 0, sizeof(server2));
  
      /* Set default address to connect to */
      server2.sin_addr.s_addr = inet_addr("127.0.0.1");    
  
      if((cpt = cfgopt(copt, "LocalSocket"))->enabled) {
+ #ifdef	C_WINDOWS
+ 	logg("^LocalSocket is not supported under Windows");
+ #else
+     if((cpt = cfgopt(copt, "LocalSocket"))->enabled) {
  
  	server.sun_family = AF_UNIX;
  	strncpy(server.sun_path, cpt->strarg, sizeof(server.sun_path));
***************
*** 346,360 ****
  	}
  
  	if(connect(sockd, (struct sockaddr *) &server, sizeof(struct sockaddr_un)) < 0) {
! 	    close(sockd);
  	    perror("connect()");
  	    logg("^Can't connect to clamd.\n");
  	    freecfg(copt);
  	    return -1;
  	}
! 
!     } else if((cpt = cfgopt(copt, "TCPSocket"))->enabled) {
! 
  	if((sockd = socket(SOCKET_INET, SOCK_STREAM, 0)) < 0) {
  	    perror("socket()");
  	    logg("^Can't create the socket.\n");
--- 430,453 ----
  	}
  
  	if(connect(sockd, (struct sockaddr *) &server, sizeof(struct sockaddr_un)) < 0) {
! 	    closesocket(sockd);
  	    perror("connect()");
  	    logg("^Can't connect to clamd.\n");
  	    freecfg(copt);
  	    return -1;
  	}
! #endif
!   
!       } else if((cpt = cfgopt(copt, "TCPSocket"))->enabled) {
! #ifdef  C_WINDOWS
!                 WSADATA wsaData;
! 
!                 if(WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) {
!                         logg("!Error at WSAStartup(): %d\n", WSAGetLastError());
!                         return -1;
!                 }
! #endif
!   
  	if((sockd = socket(SOCKET_INET, SOCK_STREAM, 0)) < 0) {
  	    perror("socket()");
  	    logg("^Can't create the socket.\n");
***************
*** 367,373 ****
  
  	if((cpt = cfgopt(copt, "TCPAddr"))->enabled) {
  	    if ((he = gethostbyname(cpt->strarg)) == 0) {
! 		close(sockd);
  		perror("gethostbyname()");
  		logg("^Can't lookup clamd hostname.\n");
  		freecfg(copt);
--- 460,466 ----
  
  	if((cpt = cfgopt(copt, "TCPAddr"))->enabled) {
  	    if ((he = gethostbyname(cpt->strarg)) == 0) {
! 		closesocket(sockd);
  		perror("gethostbyname()");
  		logg("^Can't lookup clamd hostname.\n");
  		freecfg(copt);
***************
*** 377,383 ****
  	}
  
  	if(connect(sockd, (struct sockaddr *) &server2, sizeof(struct sockaddr_in)) < 0) {
! 	    close(sockd);
  	    perror("connect()");
  	    logg("^Can't connect to clamd.\n");
  	    freecfg(copt);
--- 470,476 ----
  	}
  
  	if(connect(sockd, (struct sockaddr *) &server2, sizeof(struct sockaddr_in)) < 0) {
! 	    closesocket(sockd);
  	    perror("connect()");
  	    logg("^Can't connect to clamd.\n");
  	    freecfg(copt);
***************
*** 429,435 ****
  	else
  	    errors++;
  
! 	close(sockd);
  
  #if defined(ENABLE_FD_PASSING) && defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR)) && !defined(C_CYGWIN)
      } else if(!strcmp(opt->filename, "-")) { /* scan data from stdin */
--- 522,528 ----
  	else
  	    errors++;
  
! 	closesocket(sockd);
  
  #if defined(ENABLE_FD_PASSING) && defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR)) && !defined(C_CYGWIN)
      } else if(!strcmp(opt->filename, "-")) { /* scan data from stdin */
***************
*** 441,447 ****
  	else
  	    errors++;
  
! 	close(sockd);
  #else
      } else if(!strcmp(opt->filename, "-")) { /* scan data from stdin */
  	if((sockd = dconnect(opt)) < 0)
--- 534,540 ----
  	else
  	    errors++;
  
! 	closesocket(sockd);
  #else
      } else if(!strcmp(opt->filename, "-")) { /* scan data from stdin */
  	if((sockd = dconnect(opt)) < 0)
***************
*** 452,458 ****
  	else
  	    errors++;
  
! 	close(sockd);
  #endif
  
      } else {
--- 545,551 ----
  	else
  	    errors++;
  
! 	closesocket(sockd);
  #endif
  
      } else {
***************
*** 487,493 ****
  			else
  			    errors++;
  
! 			close(sockd);
  			break;
  
  		    default:
--- 580,586 ----
  			else
  			    errors++;
  
! 			closesocket(sockd);
  			break;
  
  		    default:
***************
*** 509,516 ****
  	struct stat fstat, mfstat;
  	int n, len, movefilename_size;
  	int moveflag = opt_check(opt, "move");
  	struct utimbuf ubuf;
! 
  
      if((moveflag && !(movedir = opt_arg(opt, "move"))) ||
          (!moveflag && !(movedir = opt_arg(opt, "copy")))) {
--- 602,610 ----
  	struct stat fstat, mfstat;
  	int n, len, movefilename_size;
  	int moveflag = opt_check(opt, "move");
+ #ifndef	C_WINDOWS
  	struct utimbuf ubuf;
! #endif
  
      if((moveflag && !(movedir = opt_arg(opt, "move"))) ||
          (!moveflag && !(movedir = opt_arg(opt, "copy")))) {
***************
*** 595,603 ****
  	chmod(movefilename, fstat.st_mode);
  	chown(movefilename, fstat.st_uid, fstat.st_gid);
  
! 	ubuf.actime = fstat.st_atime;
! 	ubuf.modtime = fstat.st_mtime;
! 	utime(movefilename, &ubuf);
  
  	if(moveflag && unlink(filename)) {
  	    logg("^cannot unlink '%s': %s\n", filename, strerror(errno));
--- 689,699 ----
  	chmod(movefilename, fstat.st_mode);
  	chown(movefilename, fstat.st_uid, fstat.st_gid);
  
! #ifndef	C_WINDOWS
!   	ubuf.actime = fstat.st_atime;
!   	ubuf.modtime = fstat.st_mtime;
!   	utime(movefilename, &ubuf);
! #endif
  
  	if(moveflag && unlink(filename)) {
  	    logg("^cannot unlink '%s': %s\n", filename, strerror(errno));
